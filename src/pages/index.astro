---
import Layout from "../layouts/Layout.astro";
import { getCollection } from "astro:content";

const collection = await getCollection("examples");
const examples = collection.map((c) => c.data);
const initialExample = examples.find((e) => e.highlighted)?.title;
---

<script>
  import { ppeg } from "ppegjs";

  import {
    generateSuccessfulOutput,
    findError,
    generateErrorOutput,
    generateGrammarCompileErrorOutput,
    highlightErrors,
  } from "../lib/generate-output";
  import { getSelectionOffsets, restoreSelectionOffsets } from "../lib/caret";

  // A little helper to save us from doing null checks later
  const getElement = <T extends Element>(selector: string): T => {
    const element = document.querySelector<T>(selector);
    if (!element) throw new Error("No element found: " + selector);
    return element;
  };

  const examplesSelect = getElement<HTMLSelectElement>("#examples");
  const grammar = getElement<HTMLDivElement>("#grammar");
  const input = getElement<HTMLDivElement>("#input");
  const output = getElement<HTMLDivElement>("#output");
  const jsonCheckbox = getElement<HTMLInputElement>("#json");

  type CompileOutput = ReturnType<typeof ppeg.compile>;
  type CompiledOk = Extract<CompileOutput, { ok: true }>;
  type ParseOutput = ReturnType<CompiledOk["parse"]>;

  type DemoState = {
    selectedExample: string;
    grammarText: string;
    inputText: string;
    showJson: boolean;
    compileOutput: CompileOutput | null;
    parseOutput: ParseOutput | null;
  };

  const State: DemoState = {
    selectedExample: examplesSelect.value,
    grammarText: "",
    inputText: "",
    showJson: jsonCheckbox.checked,
    compileOutput: null,
    parseOutput: null,
  };

  const updateState = (partial: Partial<DemoState>) => {
    Object.assign(State, partial);
  };

  // saves the current cursor location, compiles, then restores the location
  // necessary to ensure cursor location isn't reset after highlighting
  const runWithCaret = () => {
    const active = document.activeElement;
    const target =
      active === input || active === grammar ? (active as HTMLElement) : null;
    const selection = target ? getSelectionOffsets(target) : null;

    compile();
    render();

    if (target && selection) {
      target.focus();
      restoreSelectionOffsets(target, selection.start, selection.end);
    }
  };

  const compile = () => {
    const compileOutput = ppeg.compile(State.grammarText);
    if (!compileOutput.ok) {
      updateState({ compileOutput, parseOutput: null });
      return;
    }
    const parseOutput = compileOutput.parse(State.inputText);
    updateState({ compileOutput, parseOutput });
  };

  const render = () => {
    if (examplesSelect.value !== State.selectedExample) {
      examplesSelect.value = State.selectedExample;
    }
    if (grammar.textContent !== State.grammarText) {
      grammar.textContent = State.grammarText;
    }
    if (input.textContent !== State.inputText) {
      input.textContent = State.inputText;
    }
    if (jsonCheckbox.checked !== State.showJson) {
      jsonCheckbox.checked = State.showJson;
    }

    let outputText = "";
    let grammarHighlights: { start: number; end: number }[] = [];
    let outputHighlights: { start: number; end: number }[] = [];
    let inputHighlights: { start: number; end: number }[] = [];

    const compileOutput = State.compileOutput;
    const parseOutput = State.parseOutput;
    if (compileOutput && !compileOutput?.ok) {
      const errorOutput = generateGrammarCompileErrorOutput(
        State.grammarText,
        compileOutput,
      );
      outputText = errorOutput.text;
      grammarHighlights = errorOutput.highlights;
    } else if (parseOutput) {
      if (parseOutput.ok) {
        outputText = State.showJson
          ? JSON.stringify(parseOutput.ptree, null, 2)
          : generateSuccessfulOutput(parseOutput.ptree);
      } else {
        const errorOutput = generateErrorOutput(
          State.inputText,
          parseOutput.rules,
          parseOutput.trace_history,
        );
        outputText = errorOutput.text;
        outputHighlights = errorOutput.highlights;
        const error = findError(
          parseOutput.trace_history,
          State.inputText.length,
          State.inputText,
        );
        inputHighlights = error ? [error] : [];
      }
    }

    output.textContent = outputText;
    CSS.highlights?.clear();
    highlightErrors(grammar, grammarHighlights);
    highlightErrors(output, outputHighlights);
    highlightErrors(input, inputHighlights);
  };

  const loadSelectedExample = (selected: string) => {
    const option = getElement<HTMLOptionElement>(`#option-${selected}`);
    updateState({
      selectedExample: selected,
      grammarText: option.dataset.grammar ?? "",
      inputText: option.dataset.input ?? "",
    });
    runWithCaret();
  };

  examplesSelect.addEventListener("change", () => {
    loadSelectedExample(examplesSelect.value);
  });

  jsonCheckbox.addEventListener("change", () => {
    updateState({ showJson: jsonCheckbox.checked });
    runWithCaret();
  });

  input.addEventListener("input", () => {
    updateState({ inputText: input.textContent ?? "" });
    runWithCaret();
  });
  grammar.addEventListener("input", () => {
    updateState({ grammarText: grammar.textContent ?? "" });
    runWithCaret();
  });

  loadSelectedExample(State.selectedExample);
</script>

<Layout>
  <style is:global>
    body {
      display: grid;
      grid-template-areas:
        "grammar output"
        "input   output";
      grid-template-rows: 1fr 1fr;
      grid-template-columns: 1fr 1fr;
      width: 100%;
      height: 100vh;
      padding: 1em;
      gap: 0.5em;
      box-sizing: border-box;
    }

    #input,
    #grammar,
    #output {
      margin: 2px;
      padding: 5px;
      white-space: pre-wrap;
      font-family:
        "Courier Line Draw", "Courier Prime", "Courier New", monospace;
      resize: none;
    }

    #output {
      white-space: pre;
    }

    .content-container {
      overflow-y: scroll;
    }

    .node-label {
      border-radius: 3px;
      padding: 0 2px;
    }

    .input {
      grid-area: input;
    }

    .output {
      grid-area: output;
    }

    .footer {
      grid-area: footer;
    }

    .grammar,
    .input,
    .output {
      display: grid;
      grid-template-rows: auto 1fr;
      border: thin solid gray;
      min-height: 0; /** necessary to prevent divs from growing below screen **/
    }

    .header {
      height: 20px;
      padding: 5px;
      border-bottom: thin solid gray;
      background: whitesmoke;
      display: flex;
      justify-content: space-between;
    }

    .json {
      display: flex;
      align-items: center;
    }

    ::highlight(grammar-error),
    ::highlight(input-error),
    ::highlight(output-error) {
      content: "!";
      background-color: #ffb3ba !important;
      border-bottom: 2px solid red;
    }

    @media (max-width: 768px) {
      body {
        grid-template-areas:
          "title"
          "grammar"
          "input"
          "output"
          "footer";
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        height: auto;
      }

      /**inputs should no longer be scrollable**/
      #grammar,
      #input,
      #output {
        overflow-y: visible;
      }

      /**instead, they should grow**/
      .grammar,
      .input,
      .output {
        min-height: auto;
      }
    }
  </style>

  <div class="grammar">
    <div class="header">
      <label for="grammar">Grammar</label>
      <span class="examples">
        <label for="examples">Examples: </label>
        <select name="examples" id="examples">
          {
            examples.map(({ title, grammar, input }) => (
              <option
                id={`option-${title}`}
                value={title}
                data-grammar={grammar}
                data-input={input}
                selected={title == initialExample}
              >
                {title}
              </option>
            ))
          }
        </select>
      </span>
    </div>
    <div
      class="content-container"
      id="grammar"
      contenteditable="plaintext-only"
    >
    </div>
  </div>
  <div class="input">
    <div class="header">
      <label for="input">Input</label>
    </div>
    <div class="content-container" id="input" contenteditable="plaintext-only">
    </div>
  </div>
  <div class="output">
    <div class="header">
      Parse Tree
      <label class="json">
        JSON
        <input type="checkbox" id="json" name="json" />
      </label>
    </div>
    <div class="content-container">
      <div id="output"></div>
    </div>
  </div>
</Layout>
