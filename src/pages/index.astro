---
import Layout from "../layouts/Layout.astro";
import { getCollection } from "astro:content";

const collection = await getCollection("examples");
const examples = collection.map((c) => c.data);
const initialExample = examples.find((e) => e.highlighted)?.title;
---

<script>
  import { ppeg } from "ppegjs";

  import {
    generateTreeOutput,
    findError,
    generateTraceOutput,
    generateGrammarCompileErrorOutput,
    highlightErrors,
  } from "../lib/generate-output";
  import { getSelectionOffsets, restoreSelectionOffsets } from "../lib/caret";

  // A little helper to save us from doing null checks later
  const getElement = <T extends Element>(selector: string): T => {
    const element = document.querySelector<T>(selector);
    if (!element) throw new Error("No element found: " + selector);
    return element;
  };

  const examplesSelect = getElement<HTMLSelectElement>("#examples");
  const grammar = getElement<HTMLDivElement>("#grammar");
  const input = getElement<HTMLDivElement>("#input");
  const output = getElement<HTMLDivElement>("#output");
  const outputModeRadios = document.querySelectorAll<HTMLInputElement>(
    'input[name="output-mode"]',
  );
  const outputModeFromDom = (): OutputMode => {
    const selected = Array.from(outputModeRadios).find((r) => r.checked)?.value;
    if (selected === "trace" || selected === "json") {
      return selected;
    }
    return "tree";
  };

  type CompileOutput = ReturnType<typeof ppeg.compile>;
  type CompiledOk = Extract<CompileOutput, { ok: true }>;
  type ParseOutput = ReturnType<CompiledOk["parse"]>;
  type OutputMode = "tree" | "trace" | "json";

  type DemoState = {
    selectedExample: string;
    grammarText: string;
    inputText: string;
    outputMode: OutputMode;
    error: boolean;
  };

  const State: DemoState = {
    selectedExample: examplesSelect.value,
    grammarText: "",
    inputText: "",
    outputMode: outputModeFromDom(),
    error: false,
  };

  const updateState = (partial: Partial<DemoState>) => {
    Object.assign(State, partial);
  };

  // saves the current cursor location, compiles, then restores the location
  // necessary to ensure cursor location isn't reset after highlighting
  const runWithCaret = () => {
    const active = document.activeElement;
    const target =
      active === input || active === grammar ? (active as HTMLElement) : null;
    const selection = target ? getSelectionOffsets(target) : null;

    const { compileOutput, parseOutput } = compile();
    updateState({ error: (compileOutput.ok === false || parseOutput?.ok === false) });
    render(compileOutput, parseOutput);

    if (target && selection) {
      target.focus();
      restoreSelectionOffsets(target, selection.start, selection.end);
    }
  };

  const compile = (): {
    compileOutput: CompileOutput;
    parseOutput: ParseOutput | null;
  } => {
    const compileOutput = ppeg.compile(State.grammarText);
    if (!compileOutput.ok) {
      return { compileOutput, parseOutput: null };
    }
    const parseOutput = compileOutput.parse(State.inputText);
    return { compileOutput, parseOutput };
  };

  const render = (compileOutput: CompileOutput, parseOutput: ParseOutput) => {
    if (examplesSelect.value !== State.selectedExample) {
      examplesSelect.value = State.selectedExample;
    }
    if (grammar.textContent !== State.grammarText) {
      grammar.textContent = State.grammarText;
    }
    if (input.textContent !== State.inputText) {
      input.textContent = State.inputText;
    }

    document
      .querySelectorAll(".error-alert")
      .forEach((e) =>
        State.error ? e.classList.remove("hidden") : e.classList.add("hidden"),
      );

    for (const radio of outputModeRadios) {
      radio.checked = radio.value === State.outputMode;
    }

    let outputText = "";
    let grammarHighlights: { start: number; end: number }[] = [];
    let outputHighlights: { start: number; end: number }[] = [];
    let inputHighlights: { start: number; end: number }[] = [];

    if (compileOutput && !compileOutput?.ok) {
      const errorOutput = generateGrammarCompileErrorOutput(
        State.grammarText,
        compileOutput,
      );
      outputText = errorOutput.text;
      grammarHighlights = errorOutput.highlights;
    } else if (parseOutput) {
      if (State.outputMode === "json") {
        outputText = JSON.stringify(parseOutput.ptree, null, 2);
      } else if (State.outputMode === "trace") {
        const traceOutput = generateTraceOutput(
          State.inputText,
          parseOutput.rules,
          parseOutput.trace_history,
          parseOutput.error,
        );
        outputText = traceOutput.text;
        outputHighlights = traceOutput.highlights;
      } else {
        outputText = generateTreeOutput(parseOutput.ptree, parseOutput.error);
      }

      if (!parseOutput.ok) {
        const error = findError(
          parseOutput.trace_history,
          State.inputText.length,
          State.inputText,
        );
        inputHighlights = error ? [error] : [];
      }
    }

    output.textContent = outputText;
    CSS.highlights?.clear();
    highlightErrors(grammar, grammarHighlights);
    highlightErrors(output, outputHighlights);
    highlightErrors(input, inputHighlights);
  };

  const loadSelectedExample = (selected: string) => {
    const option = getElement<HTMLOptionElement>(`#option-${selected}`);
    updateState({
      selectedExample: selected,
      grammarText: option.dataset.grammar ?? "",
      inputText: option.dataset.input ?? "",
    });
    runWithCaret();
  };

  examplesSelect.addEventListener("change", () => {
    loadSelectedExample(examplesSelect.value);
  });

  for (const radio of outputModeRadios) {
    radio.addEventListener("change", () => {
      const outputMode = outputModeFromDom();
      updateState({ outputMode });
      runWithCaret();
    });
  }

  input.addEventListener("input", () => {
    updateState({ inputText: input.textContent ?? "" });
    runWithCaret();
  });
  grammar.addEventListener("input", () => {
    updateState({ grammarText: grammar.textContent ?? "" });
    runWithCaret();
  });

  loadSelectedExample(State.selectedExample);
</script>

<Layout>
  <style is:global>
    body {
      display: grid;
      grid-template-areas:
        "grammar output"
        "input   output";
      grid-template-rows: 1fr 1fr;
      grid-template-columns: 1fr 1fr;
      width: 100%;
      height: 100vh;
      padding: 1em;
      gap: 0.5em;
      box-sizing: border-box;
    }

    #input,
    #grammar,
    #output {
      margin: 2px;
      padding: 5px;
      white-space: pre-wrap;
      font-family:
        "Courier Line Draw", "Courier Prime", "Courier New", monospace;
      resize: none;
    }

    #output {
      white-space: pre;
    }

    .content-container {
      overflow-y: scroll;
    }

    .node-label {
      border-radius: 3px;
      padding: 0 2px;
    }

    .input {
      grid-area: input;
    }

    .output {
      grid-area: output;
    }

    .footer {
      grid-area: footer;
    }

    .grammar,
    .input,
    .output {
      display: grid;
      grid-template-rows: auto 1fr;
      border: thin solid gray;
      min-height: 0; /** necessary to prevent divs from growing below screen **/
    }

    .header {
      height: 20px;
      padding: 5px;
      border-bottom: thin solid gray;
      background: whitesmoke;
      display: flex;
      justify-content: space-between;
    }

    .output-mode {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .output-mode-option {
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
    }

    ::highlight(grammar-error),
    ::highlight(input-error),
    ::highlight(output-error) {
      content: "!";
      background-color: #ffb3ba !important;
      border-bottom: 2px solid red;
    }

    .error-alert {
      flex-grow: 1;
      padding-left: 0.3em;
    }

    .hidden {
      display: none;
    }

    @media (max-width: 768px) {
      body {
        grid-template-areas:
          "title"
          "grammar"
          "input"
          "output"
          "footer";
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        height: auto;
      }

      /**inputs should no longer be scrollable**/
      #grammar,
      #input,
      #output {
        overflow-y: visible;
      }

      /**instead, they should grow**/
      .grammar,
      .input,
      .output {
        min-height: auto;
      }
    }
  </style>

  <div class="grammar">
    <div class="header">
      <label for="grammar">Grammar</label>
      <span class="examples">
        <label for="examples">Examples: </label>
        <select name="examples" id="examples">
          {
            examples.map(({ title, grammar, input }) => (
              <option
                id={`option-${title}`}
                value={title}
                data-grammar={grammar}
                data-input={input}
                selected={title == initialExample}
              >
                {title}
              </option>
            ))
          }
        </select>
      </span>
    </div>
    <div
      class="content-container"
      id="grammar"
      contenteditable="plaintext-only"
    >
    </div>
  </div>
  <div class="input">
    <div class="header">
      <label for="input">Input</label>
    </div>
    <div class="content-container" id="input" contenteditable="plaintext-only">
    </div>
  </div>
  <div class="output">
    <div class="header">
      Parse Tree
      <span class="error-alert" title="An error occurred during processing"
        >⚠️</span
      >
      <span class="output-mode">
        <label class="output-mode-option">
          <input type="radio" name="output-mode" value="tree" checked />
          Tree
        </label>
        <label class="output-mode-option">
          <input type="radio" name="output-mode" value="trace" />
          Trace
        </label>
        <label class="output-mode-option">
          <input type="radio" name="output-mode" value="json" />
          JSON
        </label>
      </span>
    </div>
    <div class="content-container">
      <div id="output"></div>
    </div>
  </div>
</Layout>
