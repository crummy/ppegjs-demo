---
import Layout from "../layouts/Layout.astro";
import { getCollection } from "astro:content";

const collection = await getCollection("examples");
const examples = collection.map((c) => c.data);
const initialExample = examples.find((e) => e.highlighted)?.title;
---

<script>
  import { ppeg } from "ppegjs";

  import {
    generateSuccessfulOutput,
    findError,
    generateErrorOutput,
    generateGrammarCompileErrorOutput,
    highlightErrors,
  } from "../lib/generate-output";
  import { getSelectionOffsets, restoreSelectionOffsets } from "../lib/caret";

  // A little helper to save us from doing null checks later
  const getElement = <T extends Element>(selector: string): T => {
    const element = document.querySelector<T>(selector);
    if (!element) throw new Error("No element found: " + selector);
    return element;
  };

  const examplesSelect = getElement<HTMLSelectElement>("#examples");
  const grammar = getElement<HTMLDivElement>("#grammar");
  const input = getElement<HTMLDivElement>("#input");
  const output = getElement<HTMLDivElement>("#output");
  const jsonCheckbox = getElement<HTMLInputElement>("#json");

  const load = () => {
    const selected = examplesSelect.value;
    const option = getElement<HTMLOptionElement>(`#option-${selected}`);
    input.textContent = option.dataset.input ?? "";
    grammar.textContent = option.dataset.grammar ?? "";
    runWithCaret();
  };

  // saves the current cursor location, compiles, then restores the location
  // necessary to ensure cursor location isn't reset after highlighting
  const runWithCaret = () => {
    const active = document.activeElement;
    const target =
      active === input || active === grammar ? (active as HTMLElement) : null;
    const selection = target ? getSelectionOffsets(target) : null;

    run();

    if (target && selection) {
      target.focus();
      restoreSelectionOffsets(target, selection.start, selection.end);
    }
  };

  const run = () => {
    CSS.highlights?.clear();

    const grammarText = grammar.textContent ?? "";
    const inputText = input.textContent ?? "";
    const compiled = ppeg.compile(grammarText);
    if (!compiled.ok) {
      console.error(compiled);
      const errorOutput = generateGrammarCompileErrorOutput(
        grammarText,
        compiled,
      );
      output.textContent = errorOutput.text;
      // Highlight the grammar fault location when available.
      highlightErrors(grammar, errorOutput.highlights[0]);
    } else {
      // Grammar is valid, so clear any stale grammar highlight.
      const parsed = compiled.parse(inputText);

      const showJson = jsonCheckbox.checked;
      if (parsed.ok) {
        if (showJson) {
          output.textContent = JSON.stringify(parsed.ptree, null, 2);
        } else {
          output.innerHTML = generateSuccessfulOutput(parsed.ptree);
        }
      } else {
        if (showJson) {
          output.textContent = parsed.show_err();
        } else {
          const errorOutput = generateErrorOutput(
            inputText,
            parsed.rules,
            parsed.trace_history,
          );
          output.textContent = errorOutput.text;
        }
        // Highlight input error with line/column
        const error = findError(
          parsed.trace_history,
          inputText.length,
          inputText,
        );
        highlightErrors(input, error);
      }
    }
  };

  examplesSelect.addEventListener("change", load);

  jsonCheckbox.addEventListener("change", runWithCaret);

  input.addEventListener("input", runWithCaret);
  grammar.addEventListener("input", runWithCaret);

  load();
</script>

<Layout>
  <style is:global>
    body {
      display: grid;
      grid-template-areas:
        "grammar output"
        "input   output";
      grid-template-rows: 1fr 1fr;
      grid-template-columns: 1fr 1fr;
      width: 100%;
      height: 100vh;
      padding: 1em;
      gap: 0.5em;
      box-sizing: border-box;
    }

    #input,
    #grammar,
    #output {
      margin: 2px;
      padding: 5px;
      white-space: pre-wrap;
      font-family:
        "Courier Line Draw", "Courier Prime", "Courier New", monospace;
      resize: none;
    }

    #output {
      white-space: pre;
    }

    .content-container {
      overflow-y: scroll;
    }

    .node-label {
      border-radius: 3px;
      padding: 0 2px;
    }

    .input {
      grid-area: input;
    }

    .output {
      grid-area: output;
    }

    .footer {
      grid-area: footer;
    }

    .grammar,
    .input,
    .output {
      display: grid;
      grid-template-rows: auto 1fr;
      border: thin solid gray;
      min-height: 0; /** necessary to prevent divs from growing below screen **/
    }

    .header {
      height: 20px;
      padding: 5px;
      border-bottom: thin solid gray;
      background: whitesmoke;
      display: flex;
      justify-content: space-between;
    }

    .json {
      display: flex;
      align-items: center;
    }

    ::highlight(grammar-error),
    ::highlight(input-error) {
      content: "!";
      background-color: #ffb3ba !important;
      border-bottom: 2px solid red;
    }

    @media (max-width: 768px) {
      body {
        grid-template-areas:
          "title"
          "grammar"
          "input"
          "output"
          "footer";
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        height: auto;
      }

      /**inputs should no longer be scrollable**/
      #grammar,
      #input,
      #output {
        overflow-y: visible;
      }

      /**instead, they should grow**/
      .grammar,
      .input,
      .output {
        min-height: auto;
      }
    }
  </style>

  <div class="grammar">
    <div class="header">
      <label for="grammar">Grammar</label>
      <span class="examples">
        <label for="examples">Examples: </label>
        <select name="examples" id="examples">
          {
            examples.map(({ title, grammar, input }) => (
              <option
                id={`option-${title}`}
                value={title}
                data-grammar={grammar}
                data-input={input}
                selected={title == initialExample}
              >
                {title}
              </option>
            ))
          }
        </select>
      </span>
    </div>
    <div
      class="content-container"
      id="grammar"
      contenteditable="plaintext-only"
    >
    </div>
  </div>
  <div class="input">
    <div class="header">
      <label for="input">Input</label>
    </div>
    <div class="content-container" id="input" contenteditable="plaintext-only">
    </div>
  </div>
  <div class="output">
    <div class="header">
      Parse Tree
      <label class="json">
        JSON
        <input type="checkbox" id="json" name="json" />
      </label>
    </div>
    <div class="content-container">
      <div id="output"></div>
    </div>
  </div>
</Layout>
