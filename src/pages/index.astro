---
import Layout from "../layouts/Layout.astro";
import { getCollection } from "astro:content";

const collection = await getCollection("examples");
const examples = collection.map((c) => c.data);
const initialExample = examples.find((e) => e.highlighted)?.title;
---

<script>
  import { ppeg } from "ppegjs";
  import { debounce } from "../lib/debounce";

  import { generateOutput, findError } from "../lib/generate-output";
  import { getSelectionOffsets, restoreSelectionOffsets } from "../lib/caret";

  // A little helper to save us from doing null checks later
  const getElement = <T extends Element>(selector: string): T => {
    const element = document.querySelector<T>(selector);
    if (!element) throw new Error("No element found: " + selector);
    return element;
  };

  const examplesSelect = getElement<HTMLSelectElement>("#examples");
  const grammar = getElement<HTMLDivElement>("#grammar");
  const input = getElement<HTMLDivElement>("#input");
  const output = getElement<HTMLDivElement>("#output");
  const jsonCheckbox = getElement<HTMLInputElement>("#json");

  const load = () => {
    const selected = examplesSelect.value;
    const option = getElement<HTMLOptionElement>(`#option-${selected}`);
    input.textContent = option.dataset.input ?? "";
    grammar.textContent = option.dataset.grammar ?? "";
    runWithCaret();
  };

  const debouncedRun = debounce(() => runWithCaret(), 300);

  // saves the current cursor location, compiles, then restores the location
  // necessary to ensure cursor location isn't reset after highlighting
  const runWithCaret = () => {
    const active = document.activeElement;
    const target =
      active === input || active === grammar ? (active as HTMLElement) : null;
    const selection = target ? getSelectionOffsets(target) : null;

    run();

    if (target && selection) {
      target.focus();
      restoreSelectionOffsets(target, selection.start, selection.end);
    }
  };

  const run = () => {
    const compiled = ppeg.compile(grammar.innerText);
    if (!compiled.ok) {
      output.innerHTML = generateOutput(compiled.ptree_metadata);
      // Highlight all grammar errors with line/column
      const error = findError(compiled.ptree_metadata);
      grammar.innerHTML = highlightErrors(grammar.innerText, error);
    } else {
      const parsed = compiled.parse(input.innerText);
      console.log(parsed);

      const showJson = jsonCheckbox.checked;
      if (!showJson) {
        output.innerHTML = generateOutput(parsed.ptree_metadata);
      }

      if (parsed.ok) {
        // Figure out how to handle highlights for showJson later
        if (showJson) {
          output.innerText = JSON.stringify(parsed.ptree, null, 2);
        }
        input.innerHTML = input.innerText; // clear any error highlights
      } else {
        if (showJson) {
          output.innerText = parsed.show_err();
        }
        // Highlight all input errors with line/column
        const error = findError(parsed.ptree_metadata);
        input.innerHTML = highlightErrors(input.innerText, error);
      }
    }
  };

  // this assumes errors are a range... is that necessary? or are they always
  // just one character?
  function highlightErrors(
    text: string,
    error: { start: number; end: number } | null,
  ) {
    if (!error) return text;

    const range = {
      start: Math.max(0, error.start),
      end: Math.max(0, error.end),
    };
    if (range.end < range.start) return text;

    let result = "";
    let open = false;

    for (let i = 0; i < text.length; i++) {
      if (!open && i === range.start) {
        result += `<span class="input-error-highlight">`;
        open = true;
      }

      result += text[i];

      if (open && i === range.end) {
        result += `</span>`;
        open = false;
      }
    }

    // special handling for errors past the end of the input - e.g. an extra
    // character. have to put a little special unselectable span.
    if (open) {
      if (range.start < text.length) {
        // Range extends past the end; show a placeholder highlight cell.
        result += `</span><span class="input-error-highlight input-error-placeholder" contenteditable="false"></span>`;
        open = false;
      }
    }

    if (range.start >= text.length) {
      // Range starts at/after end; show a placeholder highlight cell.
      result += `<span class="input-error-highlight input-error-placeholder" contenteditable="false"></span>`;
    }

    return result;
  }

  examplesSelect.addEventListener("change", load);

  jsonCheckbox.addEventListener("change", runWithCaret);

  input.addEventListener("input", debouncedRun);
  grammar.addEventListener("input", debouncedRun);

  load();
</script>

<Layout>
  <style is:global>
    body {
      display: grid;
      grid-template-areas:
        "grammar output"
        "input   output";
      grid-template-rows: 1fr 1fr;
      grid-template-columns: 1fr 1fr;
      width: 100%;
      height: 100vh;
      padding: 1em;
      gap: 0.5em;
      box-sizing: border-box;
    }

    #input,
    #grammar,
    #output {
      margin: 2px;
      padding: 5px;
      white-space: pre-wrap;
      font-family:
        "Courier Line Draw", "Courier Prime", "Courier New", monospace;
      resize: none;
      overflow-y: scroll;
    }

    .node-label {
      border-radius: 3px;
      padding: 0 2px;
    }

    .input {
      grid-area: input;
    }

    .output {
      grid-area: output;
    }

    .footer {
      grid-area: footer;
    }

    .grammar,
    .input,
    .output {
      display: grid;
      grid-template-rows: auto 1fr;
      border: thin solid gray;
      min-height: 0; /** necessary to prevent divs from growing below screen **/
    }

    .header {
      height: 20px;
      padding: 5px;
      border-bottom: thin solid gray;
      background: whitesmoke;
      display: flex;
      justify-content: space-between;
    }

    .json {
      display: flex;
      align-items: center;
    }

    .grammar-error-highlight {
      background-color: #ffb3ba !important;
      border-bottom: 2px solid red;
    }
    .input-error-highlight {
      background-color: #ffb3ba !important;
      border-bottom: 2px solid red;
    }
    .input-error-placeholder {
      display: inline-block;
      position: relative;
      vertical-align: baseline;
      user-select: none;
      pointer-events: none;
    }
    .input-error-placeholder::after {
      content: " ";
      display: inline-block;
      background-color: #ffb3ba;
      border-bottom: 2px solid red;
    }

    @media (max-width: 768px) {
      body {
        grid-template-areas:
          "title"
          "grammar"
          "input"
          "output"
          "footer";
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        height: auto;
      }

      /**inputs should no longer be scrollable**/
      #grammar,
      #input,
      #output {
        overflow-y: visible;
      }

      /**instead, they should grow**/
      .grammar,
      .input,
      .output {
        min-height: auto;
      }
    }
  </style>

  <div class="grammar">
    <div class="header">
      <label for="grammar">Grammar</label>
      <span class="examples">
        <label for="examples">Examples: </label>
        <select name="examples" id="examples">
          {
            examples.map(({ title, grammar, input }) => (
              <option
                id={`option-${title}`}
                value={title}
                data-grammar={grammar}
                data-input={input}
                selected={title == initialExample}
              >
                {title}
              </option>
            ))
          }
        </select>
      </span>
    </div>
    <div class="content-container" id="grammar" contenteditable></div>
  </div>
  <div class="input">
    <div class="header">
      <label for="input">Input</label>
    </div>
    <div class="content-container" id="input" contenteditable></div>
  </div>
  <div class="output">
    <div class="header">
      Parse Tree
      <label class="json">
        JSON
        <input type="checkbox" id="json" name="json" />
      </label>
    </div>
    <div class="content-container">
      <div id="output"></div>
    </div>
  </div>
</Layout>
