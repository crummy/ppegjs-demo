---
import Layout from "../layouts/Layout.astro";
import { getCollection } from "astro:content";

const collection = await getCollection("examples");
const examples = collection.map((c) => c.data);
const initialExample = examples.find((e) => e.highlighted)?.title;
---

<script>
  // @ts-ignore - why is this not working? TODO
  import { ppeg, type Metadata } from "ppegjs";
  import { debounce } from "../lib/debounce";

  import { EditorView, basicSetup } from "codemirror";
  import { EditorState } from "@codemirror/state";
  import { grammarHighlightsPlugin } from "../lib/highlight-grammar";
  import {
    inputHighlightsPlugin,
    metadataField,
    updateMetadata,
  } from "../lib/highlight-input";
  import { standardKeymap } from "@codemirror/commands";
  import { keymap } from "@codemirror/view";

  const DESKTOP_SIZE = 768;

  // A little helper to save us from doing null checks later
  const getElement = <T extends Element>(selector: string): T => {
    const element = document.querySelector<T>(selector);
    if (!element) throw new Error("No element found: " + selector);
    return element;
  };

  const examplesSelect = getElement<HTMLSelectElement>("#examples");
  const grammar = getElement<HTMLDivElement>("#grammar");
  const input = getElement<HTMLDivElement>("#input");
  const output = getElement<HTMLDivElement>("#output");
  const jsonCheckbox = getElement<HTMLInputElement>("#json");

  const load = () => {
    const selected = examplesSelect.value;
    const option = getElement<HTMLOptionElement>(`#option-${selected}`);
    grammarView.dispatch({
      changes: {
        from: 0,
        insert: option.dataset.grammar ?? "",
      },
    });
    inputView.dispatch({
      changes: {
        from: 0,
        insert: option.dataset.input ?? "",
      },
    });
    run();
  };

  const grammarView = new EditorView({
    state: EditorState.create({
      doc: "",
      extensions: [
        keymap.of(standardKeymap),
        grammarHighlightsPlugin,
        EditorView.updateListener.of(debounce(() => run(), 300)),
      ],
    }),
    parent: grammar,
  });

  // Create input editor
  const inputView = new EditorView({
    state: EditorState.create({
      doc: "",
      extensions: [
        keymap.of(standardKeymap),
        metadataField,
        inputHighlightsPlugin,
        EditorView.updateListener.of(debounce(() => run(), 300)),
      ],
    }),
    parent: input,
  });

  const run = () => {
    output.classList.remove("compile-failed");
    input.classList.remove("compile-failed");
    grammar.classList.remove("compile-failed");

    const compiled = ppeg.compile(grammarView.state.doc.toString());
    if (!compiled.ok) {
      grammar.classList.add("compile-failed");
      output.classList.add("compile-failed");
      const treeRoot = document.createElement("ul");
      treeRoot.classList.add("parse-tree-root");
      treeRoot.appendChild(generateOutput(compiled.ptree_metadata));
      output.replaceChildren(treeRoot);
    } else {
      const parsed = compiled.parse(inputView.state.doc.toString());
      updateMetadata(inputView, parsed.ptree_metadata);

      const showJson = jsonCheckbox.checked;
      if (!showJson) {
        const treeRoot = document.createElement("ul");
        treeRoot.classList.add("parse-tree-root");
        treeRoot.appendChild(generateOutput(parsed.ptree_metadata));
        output.replaceChildren(treeRoot);
      }

      if (parsed.ok) {
        // Figure out how to handle highlights for showJson later
        if (showJson) {
          output.innerText = JSON.stringify(parsed.ptree, null, 2);
        }
      } else {
        if (showJson) {
          output.innerText = parsed.show_err();
        }
        input.classList.add("compile-failed");
        output.classList.add("compile-failed");
      }
    }
    resize(output);
    resize(grammar);
  };

  function generateOutput(tree: Metadata) {
    // Create the list item to hold this node
    const item = document.createElement("li");
    item.classList.add("tree-node");

    // Add the rule name as the node label with proper attributes
    const label = document.createElement("span");
    label.classList.add("node-label");
    if (!tree.error) {
      label.textContent = tree.rule;
      if (tree.match) {
        label.textContent += `: ${tree.match}`;
      }
    } else {
      item.classList.add("error");
      label.textContent += `${tree.error.type}: ${tree.error.message}`;
    }
    label.dataset.rule = tree.rule;
    label.dataset.matchid = tree.id?.toString();

    // Add event listeners for highlighting
    label.addEventListener("mouseover", () => {
      document
        .querySelectorAll(
          `#input [data-matchid='${tree.id}'], #grammar [data-rule='${tree.rule}']`,
        )
        .forEach((el) => el.classList.add("highlighted"));
      label.classList.add("highlighted");
    });

    label.addEventListener("mouseleave", () => {
      document
        .querySelectorAll(
          `#input [data-matchid='${tree.id}'], #grammar [data-rule='${tree.rule}']`,
        )
        .forEach((el) => el.classList.remove("highlighted"));
      label.classList.remove("highlighted");
    });

    item.appendChild(label);

    // Add children if they exist
    if (tree.children && tree.children.length > 0) {
      const childList = document.createElement("ul");
      childList.classList.add("tree-children");

      for (let leaf of tree.children) {
        childList.appendChild(generateOutput(leaf));
      }

      item.appendChild(childList);
    }

    return item;
  }

  const autoparse = debounce(run);

  const resize = (el: HTMLElement) => {
    if (document.body.clientWidth <= DESKTOP_SIZE) {
      el.style.height = "0";
      el.style.height = el.scrollHeight + "px";
    } else {
      el.style.height = "auto";
    }
  };

  examplesSelect.addEventListener("change", load);

  // Add input event listeners
  grammar.addEventListener("input", autoparse);
  input.addEventListener("input", autoparse);

  // Add input event listeners for resizing
  [grammar, input, output].forEach((el) =>
    el.addEventListener("input", () => resize(el)),
  );

  // Resize on window resize
  window.addEventListener("resize", () =>
    [grammar, input, output].forEach(resize),
  );

  jsonCheckbox.addEventListener("change", run);

  load();
  [grammar, input, output].forEach(resize);
</script>

<Layout>
  <style is:global>
    body {
      display: grid;
      grid-template-areas:
        "grammar output"
        "input   output";
      grid-template-rows: 1fr 1fr;
      grid-template-columns: 1fr 1fr;
      width: 100%;
      height: 100vh;
      padding: 1em;
      gap: 0.5em;
      box-sizing: border-box;
    }

    /* Content container with overlay setup */
    .content-container {
      position: relative;
      flex: 1;
      overflow: auto;
      min-height: 0;
    }

    #grammar,
    #input,
    #output {
      margin: 2px;
      padding: 5px;
      white-space: pre-wrap;
      font-family:
        "Courier Line Draw", "Courier Prime", "Courier New", monospace;
      line-height: 1.5;
    }

    #grammar,
    #input,
    #output {
      position: relative;
      z-index: 0;
    }

    /* Mouse tracking overlay for hover detection */
    .hover-detector {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 3; /* Above content for hover, but transparent for clicks */
      pointer-events: auto; /* Capture hover events */
    }

    /* Make spans in the overlay appear in the right positions */
    .hover-detector span {
      position: absolute;
      display: inline-block;
      background: transparent;
      cursor: pointer;
    }

    /* Active highlight for matched elements */
    .highlighted {
      background-color: rgba(100, 200, 255, 0.3);
      box-shadow: 0 0 0 1px rgba(0, 100, 200, 0.4);
      border-radius: 2px;
    }

    /* Original styles */
    .title {
      grid-area: title;
    }

    .grammar {
      grid-area: grammar;
    }

    .input {
      grid-area: input;
    }

    .output {
      grid-area: output;
    }

    .footer {
      grid-area: footer;
    }

    .grammar,
    .input,
    .output {
      display: grid;
      grid-template-rows: auto 1fr;
      border: thin solid gray;
      min-height: 0; /** necessary to prevent divs from growing below screen **/
    }

    .header {
      height: 20px;
      padding: 5px;
      border-bottom: thin solid gray;
      background: whitesmoke;
      display: flex;
      justify-content: space-between;
    }

    #grammar,
    #output {
      font-family:
        "Courier Line Draw", "Courier Prime", "Courier New", monospace;
      white-space: pre-wrap;
      margin: 2px;
      padding: 5px;
      overflow-y: auto;
      resize: none;
    }

    .compile-failed {
      background-color: tan;
    }

    .json {
      display: flex;
      align-items: center;
    }

    @media (max-width: 768px) {
      body {
        grid-template-areas:
          "title"
          "grammar"
          "input"
          "output"
          "footer";
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        height: auto;
      }

      /**inputs should no longer be scrollable**/
      #grammar,
      #input,
      #output {
        overflow-y: visible;
      }

      /**instead, they should grow**/
      .grammar,
      .input,
      .output {
        min-height: auto;
      }
    }

    /* Add these to your style block */
    .tree-node {
      list-style-type: none;
      position: relative;
    }

    .node-label {
      cursor: pointer;
      display: inline-block;
      padding: 2px 5px;
      border-radius: 3px;
    }

    .node-label:hover {
      background-color: rgba(100, 200, 255, 0.2);
    }

    .tree-children {
      padding-left: 20px;
      position: relative;
    }

    /* Folder-like connector lines */
    .error::before {
      content: "ðŸ›‘";
    }

    .error {
      color: red;
      font-weight: bold;
    }

    .tree-children:not(.error)::before {
      content: "";
      position: absolute;
      left: 8px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ccc;
    }

    .tree-node:not(.error)::before {
      content: "";
      position: absolute;
      left: -12px;
      top: 10px;
      width: 12px;
      height: 1px;
      background: #ccc;
    }

    /* Make it display properly in our output element */
    #output ul {
      padding-left: 20px;
      margin: 0;
    }

    #output > ul {
      padding-left: 0;
    }
  </style>

  <div class="grammar">
    <div class="header">
      <label for="grammar">Grammar</label>
      <span class="examples">
        <label for="examples">Examples: </label>
        <select name="examples" id="examples">
          {
            examples.map(({ title, grammar, input }) => (
              <option
                id={`option-${title}`}
                value={title}
                data-grammar={grammar}
                data-input={input}
                selected={title == initialExample}
              >
                {title}
              </option>
            ))
          }
        </select>
      </span>
    </div>
    <div class="content-container" id="grammar"></div>
  </div>
  <div class="input">
    <div class="header">
      <label for="input">Input</label>
    </div>
    <div class="content-container" id="input"></div>
  </div>
  <div class="output">
    <div class="header">
      Parse Tree
      <label class="json">
        JSON
        <input type="checkbox" id="json" name="json" />
      </label>
    </div>
    <div class="content-container">
      <div id="output"></div>
    </div>
  </div>
</Layout>
