---
import Layout from "../layouts/Layout.astro";
import { getCollection } from "astro:content";

const collection = await getCollection("examples");
const examples = collection.map((c) => c.data);
const initialExample = examples.find((e) => e.highlighted)?.title;
---

<script>
  import { ppeg } from "ppegjs";
  import type { Metadata } from "ppegjs";
  import { preserveCursorPosition } from "../lib/preserve-cursor";
  import { debounce } from "../lib/debounce";

  const DESKTOP_SIZE = 768;

  const getElement = <T extends Element>(selector: string): T => {
    const element = document.querySelector<T>(selector);
    if (!element) throw new Error("No element found: " + selector);
    return element;
  };

  const examplesSelect = getElement<HTMLSelectElement>("#examples");
  const grammar = getElement<HTMLDivElement>("#grammar");
  const input = getElement<HTMLDivElement>("#input");
  const output = getElement<HTMLDivElement>("#output");
  const jsonCheckbox = getElement<HTMLInputElement>("#json");

  const load = () => {
    const selected = examplesSelect.value;
    const option = getElement<HTMLOptionElement>(`#option-${selected}`);
    grammar.innerText = option.dataset.grammar ?? "";
    input.innerText = option.dataset.input ?? "";
    run();
  };

  const run = () => {
    output.classList.remove("compile-failed");
    input.classList.remove("compile-failed");
    grammar.classList.remove("compile-failed");

    const compiled = ppeg.compile(grammar.innerText);
    if (!compiled.ok) {
      grammar.classList.add("compile-failed");
      output.classList.add("compile-failed");
      preserveCursorPosition(grammar, () =>
        grammar.replaceChildren(generateGrammarHighlights(grammar.innerText)),
      );
      preserveCursorPosition(input, () =>
        input.replaceChildren(
          generateInputHighlights(input.innerText, compiled.ptree_metadata),
        ),
      );
      const treeRoot = document.createElement("ul");
      treeRoot.classList.add("parse-tree-root");
      treeRoot.appendChild(generateOutput(compiled.ptree_metadata));
      output.replaceChildren(treeRoot);
    } else {
      const parsed = compiled.parse(input.innerText);
      const showJson = jsonCheckbox.checked;

      if (!showJson) {
        const treeRoot = document.createElement("ul");
        treeRoot.classList.add("parse-tree-root");
        treeRoot.appendChild(generateOutput(parsed.ptree_metadata));
        output.replaceChildren(treeRoot);
      }

      if (parsed.ok) {
        // Figure out how to handle highlights for showJson later
        if (showJson) {
          output.innerText = JSON.stringify(parsed.ptree, null, 2);
        }
        preserveCursorPosition(grammar, () =>
          grammar.replaceChildren(generateGrammarHighlights(grammar.innerText)),
        );
        preserveCursorPosition(input, () =>
          input.replaceChildren(
            generateInputHighlights(input.innerText, parsed.ptree_metadata),
          ),
        );
      } else {
        if (showJson) {
          output.innerText = parsed.show_err();
        }
        input.classList.add("compile-failed");
        output.classList.add("compile-failed");
      }
    }
    resize(output);
    resize(grammar);
  };

  function generateInputHighlights(text: string, metadata: Metadata) {
    const matches: { rule: string; start: number; end: number; id: number }[] =
      [];
    function addMatches({ rule, start, end, id, children }: Metadata) {
      matches.push({ rule, start, end, id });
      children.forEach(addMatches);
    }
    addMatches(metadata);

    const element = document.createDocumentFragment();

    // If no input or no matches, just show the plain text
    if (!text || !matches || matches.length === 0) {
      element.appendChild(document.createTextNode(text));
      return element;
    }

    // Create an array of all positions where highlighting changes
    const positions = new Set<number>();
    positions.add(0);
    positions.add(text.length);

    for (const match of matches) {
      positions.add(match.start);
      positions.add(match.end);
    }

    const sortedPositions = Array.from(positions).sort((a, b) => a - b);

    // Process each segment between positions
    for (let i = 0; i < sortedPositions.length - 1; i++) {
      const start = sortedPositions[i];
      const end = sortedPositions[i + 1];

      if (start === end) continue;

      const segment = text.substring(start, end);

      // Find all matches that cover this segment
      const coveringMatches = matches
        .filter((match) => match.start <= start && match.end >= end)
        .sort((a, b) => {
          const aLength = a.end - a.start;
          const bLength = b.end - b.start;
          // Sort by length (descending)
          // That way we can highlight the narrowest match, instead of the entire thing (which is always matched)
          return bLength - aLength;
        });

      if (coveringMatches.length === 0) {
        // No matches, just add the text
        element.appendChild(document.createTextNode(segment));
      } else {
        // Create nested spans for all matches
        let currentElement: DocumentFragment | HTMLSpanElement =
          document.createDocumentFragment();
        const rootElement = currentElement;

        // Add a span for each match
        for (const match of coveringMatches) {
          const span = document.createElement("span");
          span.className = "match";
          span.dataset.rule = match.rule;
          span.dataset.matchid = match.id.toString();

          // Add event listeners
          span.addEventListener("mouseover", (e) => {
            e.stopPropagation(); // otherwise we highlight lots of matches
            document
              .querySelectorAll(
                `#output [data-matchid='${match.id}'], #grammar [data-rule='${match.rule}']`,
              )
              .forEach((el) => el.classList.add("highlighted"));
            span.classList.add("highlighted");
          });

          span.addEventListener("mouseleave", (e) => {
            e.stopPropagation();
            document
              .querySelectorAll(
                `#output [data-matchid='${match.id}'], #grammar [data-rule='${match.rule}']`,
              )
              .forEach((el) => el.classList.remove("highlighted"));
            span.classList.remove("highlighted");
          });

          currentElement.appendChild(span);
          currentElement = span;
        }

        // Add the text to the innermost span
        currentElement.appendChild(document.createTextNode(segment));

        // Add the entire fragment to the highlights container
        element.appendChild(rootElement);
      }
    }
    return element;
  }

  function generateGrammarHighlights(text: string) {
    const element = document.createDocumentFragment();

    text
      .split("\n")
      .map((line) => line.match(/^(\s*)(\w+)(\s*=.*)$/) ?? ["", line, "", ""])
      .forEach(([_, before, name, after], i) => {
        if (i !== 0) {
          element.appendChild(document.createElement("br"));
        }
        const container = document.createElement("span");
        container.className = "highlight";
        if (name) container.dataset.rule = name;
        if (before) container.appendChild(document.createTextNode(before));

        if (name) {
          container.appendChild(document.createTextNode(name));
          container.addEventListener("mouseover", () => {
            document
              .querySelectorAll(
                `#output [data-rule='${name}'], #input [data-matchid='${name}']`,
              )
              .forEach((el) => el.classList.add("highlighted"));
            container.classList.add("highlighted");
          });
          container.addEventListener("mouseleave", () => {
            document
              .querySelectorAll(
                `#output [data-rule='${name}'], #input [data-match='${name}']`,
              )
              .forEach((el) => el.classList.remove("highlighted"));
            container.classList.remove("highlighted");
          });
        }

        if (after) container.appendChild(document.createTextNode(after));

        element.appendChild(container);
      });

    return element;
  }

  function generateOutput(tree: Metadata) {
    // Create the list item to hold this node
    const item = document.createElement("li");
    item.classList.add("tree-node");

    // Add the rule name as the node label with proper attributes
    const label = document.createElement("span");
    label.classList.add("node-label");
    if (!tree.error) {
      label.textContent = tree.rule;
      if (tree.match) {
        label.textContent += `: ${tree.match}`;
      }
    } else {
      item.classList.add("error");
      label.textContent += `${tree.error.type}: ${tree.error.message}`;
    }
    label.dataset.rule = tree.rule;
    label.dataset.matchid = tree.id?.toString();

    // Add event listeners for highlighting
    label.addEventListener("mouseover", () => {
      document
        .querySelectorAll(
          `#input [data-matchid='${tree.id}'], #grammar [data-rule='${tree.rule}']`,
        )
        .forEach((el) => el.classList.add("highlighted"));
      label.classList.add("highlighted");
    });

    label.addEventListener("mouseleave", () => {
      document
        .querySelectorAll(
          `#input [data-matchid='${tree.id}'], #grammar [data-rule='${tree.rule}']`,
        )
        .forEach((el) => el.classList.remove("highlighted"));
      label.classList.remove("highlighted");
    });

    item.appendChild(label);

    // Add children if they exist
    if (tree.children && tree.children.length > 0) {
      const childList = document.createElement("ul");
      childList.classList.add("tree-children");

      for (let leaf of tree.children) {
        childList.appendChild(generateOutput(leaf));
      }

      item.appendChild(childList);
    }

    return item;
  }

  const autoparse = debounce(run);

  const resize = (el: HTMLElement) => {
    if (document.body.clientWidth <= DESKTOP_SIZE) {
      el.style.height = "0";
      el.style.height = el.scrollHeight + "px";
    } else {
      el.style.height = "auto";
    }
  };

  examplesSelect.addEventListener("change", load);

  // Add input event listeners
  grammar.addEventListener("input", autoparse);
  input.addEventListener("input", autoparse);

  // Add input event listeners for resizing
  [grammar, input, output].forEach((el) =>
    el.addEventListener("input", () => resize(el)),
  );

  // Resize on window resize
  window.addEventListener("resize", () =>
    [grammar, input, output].forEach(resize),
  );

  jsonCheckbox.addEventListener("change", run);

  load();
  [grammar, input, output].forEach(resize);
</script>

<Layout>
  <style is:global>
    body {
      display: grid;
      grid-template-areas:
        "grammar output"
        "input   output";
      grid-template-rows: 1fr 1fr;
      grid-template-columns: 1fr 1fr;
      width: 100%;
      height: 100vh;
      padding: 1em;
      gap: 0.5em;
      box-sizing: border-box;
    }

    /* Content container with overlay setup */
    .content-container {
      position: relative;
      flex: 1;
      overflow: auto;
      min-height: 0;
    }

    #grammar,
    #input,
    #output {
      margin: 2px;
      padding: 5px;
      white-space: pre-wrap;
      font-family:
        "Courier Line Draw", "Courier Prime", "Courier New", monospace;
      line-height: 1.5;
    }

    #grammar,
    #input,
    #output {
      position: relative;
      z-index: 0;
    }

    /* Mouse tracking overlay for hover detection */
    .hover-detector {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 3; /* Above content for hover, but transparent for clicks */
      pointer-events: auto; /* Capture hover events */
    }

    /* Make spans in the overlay appear in the right positions */
    .hover-detector span {
      position: absolute;
      display: inline-block;
      background: transparent;
      cursor: pointer;
    }

    /* Active highlight for matched elements */
    .highlighted {
      background-color: rgba(100, 200, 255, 0.3);
      box-shadow: 0 0 0 1px rgba(0, 100, 200, 0.4);
      border-radius: 2px;
    }

    /* Original styles */
    .title {
      grid-area: title;
    }

    .grammar {
      grid-area: grammar;
    }

    .input {
      grid-area: input;
    }

    .output {
      grid-area: output;
    }

    .footer {
      grid-area: footer;
    }

    .grammar,
    .input,
    .output {
      display: grid;
      grid-template-rows: auto 1fr;
      border: thin solid gray;
      min-height: 0; /** necessary to prevent divs from growing below screen **/
    }

    .header {
      height: 20px;
      padding: 5px;
      border-bottom: thin solid gray;
      background: whitesmoke;
      display: flex;
      justify-content: space-between;
    }

    #grammar,
    #output {
      font-family:
        "Courier Line Draw", "Courier Prime", "Courier New", monospace;
      white-space: pre-wrap;
      margin: 2px;
      padding: 5px;
      overflow-y: auto;
      resize: none;
    }

    .compile-failed {
      background-color: tan;
    }

    .json {
      display: flex;
      align-items: center;
    }

    @media (max-width: 768px) {
      body {
        grid-template-areas:
          "title"
          "grammar"
          "input"
          "output"
          "footer";
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        height: auto;
      }

      /**inputs should no longer be scrollable**/
      #grammar,
      #input,
      #output {
        overflow-y: visible;
      }

      /**instead, they should grow**/
      .grammar,
      .input,
      .output {
        min-height: auto;
      }
    }

    /* Add these to your style block */
    .tree-node {
      list-style-type: none;
      position: relative;
    }

    .node-label {
      cursor: pointer;
      display: inline-block;
      padding: 2px 5px;
      border-radius: 3px;
    }

    .node-label:hover {
      background-color: rgba(100, 200, 255, 0.2);
    }

    .tree-children {
      padding-left: 20px;
      position: relative;
    }

    /* Folder-like connector lines */
    .error::before {
      content: "🛑";
    }

    .error {
      color: red;
      font-weight: bold;
    }

    .tree-children:not(.error)::before {
      content: "";
      position: absolute;
      left: 8px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ccc;
    }

    .tree-node:not(.error)::before {
      content: "";
      position: absolute;
      left: -12px;
      top: 10px;
      width: 12px;
      height: 1px;
      background: #ccc;
    }

    /* Make it display properly in our output element */
    #output ul {
      padding-left: 20px;
      margin: 0;
    }

    #output > ul {
      padding-left: 0;
    }
  </style>

  <div class="grammar">
    <div class="header">
      <label for="grammar">Grammar</label>
      <span class="examples">
        <label for="examples">Examples: </label>
        <select name="examples" id="examples">
          {
            examples.map(({ title, grammar, input }) => (
              <option
                id={`option-${title}`}
                value={title}
                data-grammar={grammar}
                data-input={input}
                selected={title == initialExample}
              >
                {title}
              </option>
            ))
          }
        </select>
      </span>
    </div>
    <div class="content-container">
      <div id="grammar" contenteditable></div>
    </div>
  </div>
  <div class="input">
    <div class="header">
      <label for="input">Input</label>
    </div>
    <div class="content-container">
      <div id="input" contenteditable></div>
    </div>
  </div>
  <div class="output">
    <div class="header">
      Parse Tree
      <label class="json">
        JSON
        <input type="checkbox" id="json" name="json" />
      </label>
    </div>
    <div class="content-container">
      <div id="output"></div>
    </div>
  </div>
</Layout>
