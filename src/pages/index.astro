---
import Layout from "../layouts/Layout.astro";
import { getCollection } from "astro:content";

const collection = await getCollection("examples");
const examples = collection.map((c) => c.data);
const initialExample = examples.find((e) => e.highlighted)?.title;
---

<script>
  import { ppeg } from "ppegjs";
  import { debounce } from "../lib/debounce";

  import { EditorView } from "codemirror";
  import { EditorState } from "@codemirror/state";
  import { grammarHighlightsPlugin } from "../lib/highlight-grammar";
  import {
    inputHighlightsPlugin,
    metadataField,
    updateMetadata,
  } from "../lib/highlight-input";
  import { standardKeymap } from "@codemirror/commands";
  import { keymap } from "@codemirror/view";
  import { generateOutput } from "../lib/generate-output";

  // A little helper to save us from doing null checks later
  const getElement = <T extends Element>(selector: string): T => {
    const element = document.querySelector<T>(selector);
    if (!element) throw new Error("No element found: " + selector);
    return element;
  };

  const examplesSelect = getElement<HTMLSelectElement>("#examples");
  const grammar = getElement<HTMLDivElement>("#grammar");
  const input = getElement<HTMLDivElement>("#input");
  const output = getElement<HTMLDivElement>("#output");
  const jsonCheckbox = getElement<HTMLInputElement>("#json");

  const load = () => {
    const selected = examplesSelect.value;
    const option = getElement<HTMLOptionElement>(`#option-${selected}`);
    grammarView.dispatch({
      changes: {
        from: 0,
        to: grammarView.state.doc.length,
        insert: option.dataset.grammar ?? "",
      },
    });
    inputView.dispatch({
      changes: {
        from: 0,
        to: inputView.state.doc.length,
        insert: option.dataset.input ?? "",
      },
    });
    run();
  };

  const noFocusRingTheme = EditorView.theme({
    // Target the focused editor and remove the outline/border
    "&.cm-focused": {
      outline: "none",
      border: "none",
    },
  });

  const debouncedRun = debounce(() => run(), 300);
  const grammarView = new EditorView({
    state: EditorState.create({
      doc: "",
      extensions: [
        noFocusRingTheme,
        keymap.of(standardKeymap),
        grammarHighlightsPlugin,
        EditorView.updateListener.of(debouncedRun),
      ],
    }),
    parent: grammar,
  });
  const inputView = new EditorView({
    state: EditorState.create({
      doc: "",
      extensions: [
        noFocusRingTheme,
        keymap.of(standardKeymap),
        metadataField,
        inputHighlightsPlugin,
        EditorView.updateListener.of((update) => {
          // Only run if content changed - otherwise when metadata updates we can get an infinite loop
          if (update.docChanged) {
            debouncedRun();
          }
        }),
      ],
    }),
    parent: input,
  });

  const run = () => {
    output.classList.remove("compile-failed");
    input.classList.remove("compile-failed");
    grammar.classList.remove("compile-failed");

    const compiled = ppeg.compile(grammarView.state.doc.toString());
    if (!compiled.ok) {
      grammar.classList.add("compile-failed");
      output.classList.add("compile-failed");
      output.replaceChildren(generateOutput(compiled.ptree_metadata));
    } else {
      const parsed = compiled.parse(inputView.state.doc.toString());

      // This will trigger re-render of input with new hoverable elements
      updateMetadata(inputView, parsed.ptree_metadata);

      const showJson = jsonCheckbox.checked;
      if (!showJson) {
        output.replaceChildren(generateOutput(parsed.ptree_metadata));
      }

      if (parsed.ok) {
        // Figure out how to handle highlights for showJson later
        if (showJson) {
          output.innerText = JSON.stringify(parsed.ptree, null, 2);
        }
      } else {
        if (showJson) {
          output.innerText = parsed.show_err();
        }
        input.classList.add("compile-failed");
        output.classList.add("compile-failed");
      }
    }
  };

  document.addEventListener("mouseover", function (e) {
    const target = e.target as HTMLElement;
    if (!target) return;

    // If it has a matchid, it's either in output or input. In this case we don't want to highlight every matching rule.
    // Instead, we highlight the matching rule in the grammar, and the matching matchid in whatever the other textinput
    // is.
    const rule = target.dataset.rule;
    const matchId = target.dataset.matchid;
    if (rule && matchId) {
      // Find and highlight all elements with the same matchId, except for grammar where we don't have matches
      document
        .querySelectorAll(
          `#grammar [data-rule="${rule}"], [data-matchid="${matchId}"]`,
        )
        .forEach((el) => el.classList.add("highlighted"));
    } else if (rule) {
      // Find and highlight all elements with the same data-rule
      document
        .querySelectorAll(`[data-rule="${rule}"]`)
        .forEach((el) => el.classList.add("highlighted"));
    }
  });

  document.addEventListener("mouseout", function (e) {
    const target = e.target as HTMLElement;
    if (!target) return;

    // Remove highlights when mouse leaves
    if (target.dataset.rule) {
      document.querySelectorAll(".highlighted").forEach((el) => {
        el.classList.remove("highlighted");
      });
    }
  });

  examplesSelect.addEventListener("change", load);

  jsonCheckbox.addEventListener("change", run);

  load();
</script>

<Layout>
  <style is:global>
    body {
      display: grid;
      grid-template-areas:
        "grammar output"
        "input   output";
      grid-template-rows: 1fr 1fr;
      grid-template-columns: 1fr 1fr;
      width: 100%;
      height: 100vh;
      padding: 1em;
      gap: 0.5em;
      box-sizing: border-box;
    }

    .cm-content,
    #output {
      margin: 2px;
      padding: 5px;
      white-space: pre-wrap;
      font-family:
        "Courier Line Draw", "Courier Prime", "Courier New", monospace;
      line-height: 1.5;
      resize: none;
    }

    /* Active highlight for matched elements */
    .highlighted {
      background-color: rgba(100, 200, 255, 0.3);
      box-shadow: 0 0 0 1px rgba(0, 100, 200, 0.4);
      border-radius: 2px;
    }

    .input {
      grid-area: input;
    }

    .output {
      grid-area: output;
    }

    .footer {
      grid-area: footer;
    }

    .grammar,
    .input,
    .output {
      display: grid;
      grid-template-rows: auto 1fr;
      border: thin solid gray;
      min-height: 0; /** necessary to prevent divs from growing below screen **/
    }

    .header {
      height: 20px;
      padding: 5px;
      border-bottom: thin solid gray;
      background: whitesmoke;
      display: flex;
      justify-content: space-between;
    }

    .compile-failed {
      background-color: tan;
    }

    .json {
      display: flex;
      align-items: center;
    }

    @media (max-width: 768px) {
      body {
        grid-template-areas:
          "title"
          "grammar"
          "input"
          "output"
          "footer";
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        height: auto;
      }

      /**inputs should no longer be scrollable**/
      #grammar,
      #input,
      #output {
        overflow-y: visible;
      }

      /**instead, they should grow**/
      .grammar,
      .input,
      .output {
        min-height: auto;
      }

      .CodeMirror {
        height: auto;
      }
    }

    /* Add these to your style block */
    .tree-node {
      list-style-type: none;
      position: relative;
    }

    .node-label {
      cursor: pointer;
      display: inline-block;
      border-radius: 3px;
    }

    .node-label:hover {
      background-color: rgba(100, 200, 255, 0.2);
    }

    .tree-children {
      padding-left: 20px;
      position: relative;
    }

    /* Folder-like connector lines */
    .error::before {
      content: "ðŸ›‘";
    }

    .error {
      color: red;
      font-weight: bold;
    }

    .tree-children:not(.error)::before {
      content: "";
      position: absolute;
      left: 8px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ccc;
    }

    .tree-node:not(.error)::before {
      content: "";
      position: absolute;
      left: -12px;
      top: 10px;
      width: 12px;
      height: 1px;
      background: #ccc;
    }

    /* Make it display properly in our output element */
    #output ul {
      padding-left: 20px;
      margin: 0;
    }

    #output > ul {
      padding-left: 0;
    }
  </style>

  <div class="grammar">
    <div class="header">
      <label for="grammar">Grammar</label>
      <span class="examples">
        <label for="examples">Examples: </label>
        <select name="examples" id="examples">
          {
            examples.map(({ title, grammar, input }) => (
              <option
                id={`option-${title}`}
                value={title}
                data-grammar={grammar}
                data-input={input}
                selected={title == initialExample}
              >
                {title}
              </option>
            ))
          }
        </select>
      </span>
    </div>
    <div class="content-container" id="grammar"></div>
  </div>
  <div class="input">
    <div class="header">
      <label for="input">Input</label>
    </div>
    <div class="content-container" id="input"></div>
  </div>
  <div class="output">
    <div class="header">
      Parse Tree
      <label class="json">
        JSON
        <input type="checkbox" id="json" name="json" />
      </label>
    </div>
    <div class="content-container">
      <div id="output"></div>
    </div>
  </div>
</Layout>
